
//------------------------------------------------------------------------------

//  <auto-generated>
//      This code was generated by:
//        TerminalGuiDesigner v2.0.0.0
//      You can make changes to this file and they will not be overwritten when saving.
//  </auto-generated>
// -----------------------------------------------------------------------------
namespace tcord
{
    using Terminal.Gui;
    using Discord;
    using Discord.WebSocket;
    using System.Reactive.Linq;
    using System.Collections.ObjectModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using Logger;
    using Terminal.Gui.Input;
    using Terminal.Gui.Views;
    using System;
    using System.Buffers;
    using System.Security.Cryptography;
    using System.IO.Abstractions;
    using System.Net.Sockets;

    public partial class MyView
    {
        private SocketChannel selCh;
        private SocketGuild selSv;
        private static DiscordSocketClient dClient;
        private IReadOnlyCollection<SocketGuild> guilds;
        private Dictionary<string, ulong> guildDict = new Dictionary<string, ulong> { };
        private Dictionary<string, ulong> channelDict = new Dictionary<string, ulong> { };
        private ObservableCollection<string> guildNames = new ObservableCollection<string> { };
        private string token;
        private IDisposable typingState;
        private bool typingDisposed = true;
        private string nowTime = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
        private Task log(LogMessage log)
        {
            string logsPath = Path.Combine(AppContext.BaseDirectory, "logs");
            string finalFilePath = logsPath + "/log_Discord_" + nowTime + ".log";
            if (Directory.Exists(logsPath) == false)
            {
                Directory.CreateDirectory(logsPath);
            }
            if (File.Exists(finalFilePath))
            {
                File.AppendAllText(finalFilePath, log.ToString());

            }
            else
            {
                File.WriteAllText(finalFilePath, log.ToString());
            }

            return Task.CompletedTask;
        }


        public MyView()
        {

            InitializeComponent();

            bool tokenExists = File.Exists(AppContext.BaseDirectory + "bot.token");
            Logger.logString(tokenExists.ToString(), nowTime, "what22");
            if (tokenExists == false)
            {
                discordTokenInputWindow.Visible = true;
                okButton.Accepting += (source, e) =>
                {
                    discordTokenInputWindow.Visible = false;
                    discordTokenInputWindow.Enabled = false;
                    File.WriteAllText(AppContext.BaseDirectory + "bot.token", inputField.Text);
                    token = File.ReadAllText(AppContext.BaseDirectory + "bot.token");
                    Main();
                };
            }
            else
            {
                token = File.ReadAllText(AppContext.BaseDirectory + "bot.token");
                Main();
            }
        }

        private async Task Main()
        {
            var config = new DiscordSocketConfig
            {
                GatewayIntents = GatewayIntents.Guilds
                   | GatewayIntents.GuildMessages
                   | GatewayIntents.DirectMessages
                   | GatewayIntents.MessageContent
            };


            dClient = new DiscordSocketClient(config);
            dClient.Log += log;

            await dClient.LoginAsync(TokenType.Bot, token);
            await dClient.StartAsync();
            guilds = dClient.Guilds;
            dClient.MessageReceived += msgRecieved;

            await updateServers();

            serverList.SelectedItemChanged += async (object sender, ListViewItemEventArgs selected) =>
            {
                selSv = dClient.GetGuild(guildDict[selected.Value.ToString()]);
                Logger.logString(selSv.Name, nowTime, "debug");
                await updateChannels();
            };

            channelListView.SelectedItemChanged += async (object sender, ListViewItemEventArgs selected) =>
           {
               selCh = dClient.GetChannel(channelDict[selected.Value.ToString()]);
               await updateMessages();
           };


            messageInput.KeyDown += (object sender, Key i) =>
            {
                if (i.KeyCode == Key.Enter)
                {
                    i.Handled = true;
                    sendMessage(messageInput.Text);
                    messageInput.Text = "";
                }
            };

            dClient.Ready += updateServers;
            Logger.logString(guildNames.ToString(), nowTime);
            await serverList.SetSourceAsync<string>(guildNames);


        }

        private async Task sendMessage(string message)
        {
            if (selCh is ITextChannel textChannel)
            {
                await textChannel.SendMessageAsync(message);
                msgBoardTexts.NeedsDraw = true;
                msgBoardTexts.Draw();
            }
        }

        private async Task updateServers()
        {
            var guilds = dClient.Guilds;
            foreach (var guild in guilds)
            {
                guildDict.Add(guild.Name, guild.Id);
                guildNames.Add(guild.Name);
                Logger.logString(guild.Name, nowTime, "serverLog");
            }
            Logger.logString(guildNames.ToString(), nowTime);
            await serverList.SetSourceAsync<string>(guildNames);
        }

        private async Task updateChannels()
        {
            await channelListView.SetSourceAsync(new ObservableCollection<string> { });
            channelDict.Clear();
            var channels = selSv.Channels.Where(c => (c is ITextChannel textCh) && ((SocketTextChannel)textCh).GetPermissionOverwrite(dClient.CurrentUser)?.ViewChannel != PermValue.Deny).ToList();
            var channelNames = new ObservableCollection<string> { };
            foreach (var channel in channels)
            {
                if (channel.ChannelType == ChannelType.Text || channel.ChannelType == ChannelType.Voice)
                {
                    channelDict.Add(channel.Name, channel.Id);
                    channelNames.Add(channel.Name);
                    Logger.logString(channel.Name, nowTime, "serverLog");
                }
            }
            Logger.logString(channelNames.ToString(), nowTime);
            await channelListView.SetSourceAsync<string>(channelNames);
            await updateMessages();
        }

        private async Task updateMessages()
        {
            if (selCh is ITextChannel textChannel)
            {
                var messageContents = new ObservableCollection<string> { };
                foreach (var message in await textChannel.GetMessagesAsync(40).FlattenAsync())
                {
                    messageContents.Add(message.Author.Username + " | " + message.Content);
                }
                Logger.logString(messageContents.ToString(), nowTime);
                await msgBoardTexts.SetSourceAsync<string>(messageContents);
            }

        }

        private async Task msgRecieved(SocketMessage message)
        {
            //await updateServers();
            var curMsgBoard = msgBoardTexts.Source.ToList();
            curMsgBoard.Insert(0, message.Author.Username + " | " + message.Content);
            await msgBoardTexts.SetSourceAsync<string>((ObservableCollection<string>)curMsgBoard);

            Logger.logString(message.Author.GlobalName + " said: " + message.Content, nowTime, "messagesLog");
        }
    }
}
